#!/usr/bin/env python3
"""
Radiant USB FPGA Programmer
Automated bitstream programming via Lattice Radiant Programmer over USB/JTAG.
"""

import argparse
import os
import sys
import subprocess
import time
import tempfile
import shutil
from pathlib import Path
from typing import Optional, Dict, Tuple
import yaml
from datetime import datetime


# XCF Template
XCF_TEMPLATE = """<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE		ispXCF	SYSTEM	"IspXCF.dtd" >
<ispXCF version="R2025.2">
	<Comment>Auto-generated by radiant_usb_programmer.py</Comment>
	<Chain>
		<Comm>JTAG</Comm>
		<Device>
			<SelectedProg value="TRUE"/>
			<Pos>1</Pos>
			<Vendor>Lattice</Vendor>
			<Family>{device_family}</Family>
			<Name>{device_name}</Name>
			<IDCode>{device_idcode}</IDCode>
			<Package>All</Package>
			<PON>{device_name}</PON>
			<Bypass>
				<InstrLen>8</InstrLen>
				<InstrVal>11111111</InstrVal>
				<BScanLen>1</BScanLen>
				<BScanVal>0</BScanVal>
			</Bypass>
			<File>{bitstream_path}</File>
			<FileTime>{file_time}</FileTime>
			<JedecChecksum>N/A</JedecChecksum>
			<MemoryType>Static Random Access Memory (SRAM)</MemoryType>
			<Operation>{operation}</Operation>
			<Option>
				<SVFVendor>JTAG STANDARD</SVFVendor>
				<IOState>HighZ</IOState>
				<PreloadLength>362</PreloadLength>
				<IOVectorData>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</IOVectorData>
				<SVFProcessor>SVF Processor</SVFProcessor>
				<Usercode>0x00000000</Usercode>
				<AccessMode>Direct Programming</AccessMode>
			</Option>
		</Device>
	</Chain>
	<ProjectOptions>
		<Program>SEQUENTIAL</Program>
		<Process>ENTIRED CHAIN</Process>
		<OperationOverride>No Override</OperationOverride>
		<StartTAP>TLR</StartTAP>
		<EndTAP>TLR</EndTAP>
		<VerifyUsercode value="FALSE"/>
		<TCKDelay>{tck_delay}</TCKDelay>
	</ProjectOptions>
	<CableOptions>
		<CableName>{cable_name}</CableName>
		<PortAdd>{port_address}</PortAdd>
		<USBID>{usb_id}</USBID>
	</CableOptions>
</ispXCF>
"""


# Error code interpretations
ERROR_CODES = {
    "85021324": "Process Operation Failed - Check device connection and power",
    "85021372": "Operation unsuccessful - Verify bitstream compatibility"
}


class RadiantUSBProgrammer:
    """Automated FPGA programming via USB/JTAG."""
    
    def __init__(self, config_path: Optional[str] = None, verbose: bool = False):
        """
        Initialize programmer.
        
        Args:
            config_path: Path to YAML configuration file
            verbose: Enable verbose output
        """
        self.verbose = verbose
        self.config_path = config_path or self._find_default_config()
        self.config = self._load_config()
        self.programmer_exe = self._find_programmer()
        self.results_dir = self._create_results_dir()
        
    def _find_default_config(self) -> str:
        """Find default config file in script directory."""
        script_dir = Path(__file__).parent
        return str(script_dir / "radiant_programmer_config.yaml")
    
    def _load_config(self) -> Dict:
        """Load configuration from YAML file."""
        if not Path(self.config_path).exists():
            self._print_error(f"Configuration file not found: {self.config_path}")
            self._print_info("Run with --setup-cable to create initial configuration")
            sys.exit(1)
        
        with open(self.config_path, 'r') as f:
            return yaml.safe_load(f)
    
    def _find_programmer(self) -> Path:
        """Locate pgrcmd.exe."""
        programmer_path = self.config.get('radiant', {}).get('programmer_path')
        
        if programmer_path:
            path = Path(programmer_path)
            if path.exists():
                return path
        
        # Auto-detect
        radiant_version = self.config.get('radiant', {}).get('version', '2025.2')
        default_path = Path(f"c:/lscc/radiant/{radiant_version}/programmer/bin/nt64/pgrcmd.exe")
        
        if default_path.exists():
            return default_path
        
        self._print_error(f"Radiant Programmer not found at: {default_path}")
        self._print_info("Update 'radiant.programmer_path' in config file")
        sys.exit(1)
    
    def _create_results_dir(self) -> Path:
        """Create timestamped results directory."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        results_dir = Path.cwd().parent / "results" / f"jtag_loc_programming_{timestamp}"
        results_dir.mkdir(parents=True, exist_ok=True)
        return results_dir
    
    def generate_xcf(
        self,
        bitstream_path: str,
        operation: str = "Erase,Program,Verify",
        output_dir: Optional[str] = None
    ) -> str:
        """
        Generate XCF project file.
        
        Args:
            bitstream_path: Absolute path to bitstream file
            operation: Programming operation
            output_dir: Directory to save XCF (default: timestamped results dir)
            
        Returns:
            Path to generated XCF file
        """
        bitstream_path = Path(bitstream_path).resolve()
        
        if not bitstream_path.exists():
            raise FileNotFoundError(f"Bitstream file not found: {bitstream_path}")
        
        # Get file timestamp
        mtime = bitstream_path.stat().st_mtime
        file_time = datetime.fromtimestamp(mtime).strftime("%m/%d/%y %H:%M:%S")
        
        # Output directory (use timestamped results dir)
        output_dir = self.results_dir
        
        # Generate XCF filename
        xcf_name = bitstream_path.stem + "_auto.xcf"
        xcf_path = output_dir / xcf_name
        
        # Fill template
        xcf_content = XCF_TEMPLATE.format(
            device_family=self.config['device']['family'],
            device_name=self.config['device']['name'],
            device_idcode=self.config['device']['idcode'],
            bitstream_path=str(bitstream_path.as_posix()),
            file_time=file_time,
            operation=operation,
            tck_delay=self.config.get('options', {}).get('tck_delay', 3),
            cable_name=self.config['cable']['name'],
            port_address=self.config['cable']['port'],
            usb_id=self.config['cable']['usb_id']
        )
        
        # Write XCF file
        with open(xcf_path, 'w', encoding='utf-8') as f:
            f.write(xcf_content)
        
        if self.verbose:
            self._print_verbose(f"Generated XCF: {xcf_path}")
        
        return str(xcf_path)
    
    def program(
        self,
        bitstream_path: str,
        operation: str = "Erase,Program,Verify",
        max_retries: int = 3
    ) -> bool:
        """
        Program FPGA with bitstream.
        
        Args:
            bitstream_path: Path to bitstream file
            operation: Programming operation
            max_retries: Number of retries on cable errors
            
        Returns:
            True if successful, False otherwise
        """
        self._print_header("FPGA Programming")
        self._print_info(f"Bitstream: {bitstream_path}")
        self._print_info(f"Operation: {operation}")
        self._print_info(f"Device: {self.config['device']['name']}")
        print("=" * 80)
        
        for attempt in range(1, max_retries + 1):
            if attempt > 1:
                self._print_warning(f"Retry attempt {attempt}/{max_retries}")
                time.sleep(2)
            
            try:
                # Generate XCF
                xcf_path = self.generate_xcf(bitstream_path, operation)
                
                # Run programmer
                success, log_path = self._run_programmer(xcf_path)
                
                if success:
                    self._print_success("Programming successful!")
                    return True
                else:
                    # Parse log for errors
                    errors = self._parse_log_errors(log_path)
                    
                    # Check if retryable (cable errors)
                    if self._is_retryable_error(errors) and attempt < max_retries:
                        self._print_warning("Cable error detected, retrying...")
                        continue
                    else:
                        self._print_error("Programming failed")
                        self._display_errors(errors)
                        return False
            
            except Exception as e:
                self._print_error(f"Exception: {e}")
                if attempt < max_retries:
                    continue
                return False
        
        self._print_error(f"Failed after {max_retries} attempts")
        return False
    
    def _run_programmer(self, xcf_path: str) -> Tuple[bool, str]:
        """
        Execute pgrcmd.exe.
        
        Returns:
            (success, log_path)
        """
        xcf_path = Path(xcf_path)
        log_path = xcf_path.parent / f"{xcf_path.stem}_log.txt"
        
        cmd = [
            str(self.programmer_exe),
            "-infile", str(xcf_path),
            "-logfile", str(log_path),
        ]
        
        self._print_info(f"Executing: {' '.join(cmd)}")
        
        try:
            start_time = time.time()
            
            # Run and capture output
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self.config.get('options', {}).get('timeout', 300),
                cwd=str(self.programmer_exe.parent)
            )
            
            elapsed_time = time.time() - start_time
            
            # Display output
            if result.stdout:
                print(result.stdout)
            if result.stderr and self.verbose:
                print(result.stderr)
            
            # Parse log file for success
            success = self._check_log_success(log_path)
            
            if success:
                self._print_info(f"Elapsed time: {elapsed_time:.1f} seconds")
            
            return success, str(log_path)
        
        except subprocess.TimeoutExpired:
            self._print_error("Programming timeout")
            return False, str(log_path)
        except Exception as e:
            self._print_error(f"Error running programmer: {e}")
            return False, str(log_path)
    
    def _check_log_success(self, log_path: str) -> bool:
        """Check log file for success indicators."""
        if not Path(log_path).exists():
            return False
        
        with open(log_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
        
        # Look for success indicators
        if "INFO <85021373> - Operation: successful" in content:
            return True
        
        if "ERROR <85021372> - Operation: unsuccessful" in content:
            return False
        
        # Check for other success patterns
        if "Operation Done. No errors" in content:
            return True
        
        return False
    
    def _parse_log_errors(self, log_path: str) -> list:
        """Parse log file for error messages."""
        errors = []
        
        if not Path(log_path).exists():
            return errors
        
        with open(log_path, 'r', encoding='utf-8', errors='ignore') as f:
            for line in f:
                if "ERROR" in line:
                    errors.append(line.strip())
        
        return errors
    
    def _is_retryable_error(self, errors: list) -> bool:
        """Check if errors are retryable (cable/connection issues)."""
        for error in errors:
            # Cable errors
            if "85021324" in error or "85021" in error:
                return True
            if "cable" in error.lower() or "connection" in error.lower():
                return True
        return False
    
    def _display_errors(self, errors: list):
        """Display parsed errors with interpretations."""
        if not errors:
            self._print_error("Unknown error - check log file")
            return
        
        self._print_error("Errors detected:")
        for error in errors:
            print(f"  {error}")
            
            # Try to provide interpretation
            for code, interpretation in ERROR_CODES.items():
                if code in error:
                    print(f"    → {interpretation}")
                    break
    
    def setup_cable(self):
        """Interactive cable setup."""
        self._print_header("Cable Configuration Setup")
        
        print("\nDetecting USB cables...")
        print("Please ensure your FPGA is connected via USB/JTAG cable.")
        print("\nRun Radiant Programmer GUI to detect cable settings:")
        print("  1. Open Radiant Programmer")
        print("  2. Go to Cable Settings")
        print("  3. Note down:")
        print("     - Cable Name (usually: USB2)")
        print("     - Port Address (e.g., FTUSB-0)")
        print("     - USB ID (e.g., 'Dual RS232-HS A Location 22321 Serial A')")
        
        print("\n" + "=" * 80)
        cable_name = input("Enter Cable Name [USB2]: ").strip() or "USB2"
        port_addr = input("Enter Port Address [FTUSB-0]: ").strip() or "FTUSB-0"
        usb_id = input("Enter USB ID: ").strip()
        
        if not usb_id:
            self._print_error("USB ID is required")
            return False
        
        # Create config
        config = {
            'radiant': {
                'version': '2025.2',
                'programmer_path': str(self.programmer_exe)
            },
            'cable': {
                'name': cable_name,
                'port': port_addr,
                'usb_id': usb_id
            },
            'device': {
                'family': 'LFCPNX',
                'name': 'LFCPNX-100',
                'idcode': '0x010f4043'
            },
            'options': {
                'tck_delay': 3,
                'timeout': 300
            }
        }
        
        # Save config
        with open(self.config_path, 'w') as f:
            yaml.dump(config, f, default_flow_style=False)
        
        self._print_success(f"Configuration saved to: {self.config_path}")
        return True
    
    # Output formatting methods
    def _print_header(self, text: str):
        print("\n" + "=" * 80)
        print(f"  {text}")
        print("=" * 80)
    
    def _print_info(self, text: str):
        print(f"[INFO] {text}")
    
    def _print_success(self, text: str):
        print(f"[✓ SUCCESS] {text}")
    
    def _print_error(self, text: str):
        print(f"[✗ ERROR] {text}")
    
    def _print_warning(self, text: str):
        print(f"[⚠ WARNING] {text}")
    
    def _print_verbose(self, text: str):
        if self.verbose:
            print(f"[VERBOSE] {text}")


def main() -> str:
    parser = argparse.ArgumentParser(
        description="Radiant USB FPGA Programmer",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument("--bitstream", type=str,
                        help="Path to bitstream file (.bit)")
    parser.add_argument("--operation", type=str,
                        default="Erase,Program,Verify",
                        choices=["Erase,Program,Verify", "Fast Configuration", 
                                "Program,Verify", "Erase,Program"],
                        help="Programming operation")
    parser.add_argument("--fast", action="store_true",
                        help="Use Fast Configuration (quick, no verify)")
    parser.add_argument("--config", type=str,
                        help="Path to configuration file")
    parser.add_argument("--setup-cable", action="store_true",
                        help="Interactive cable setup")
    parser.add_argument("--max-retries", type=int, default=3,
                        help="Maximum retry attempts on cable errors")
    parser.add_argument("--verbose", "-v", action="store_true",
                        help="Verbose output")
    
    # Fix Unicode encoding on Windows (allows ✓ and ✗ characters)
    if sys.platform == 'win32':
        import io
        sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
        sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')
    
    args = parser.parse_args()
    
    try:
        programmer = RadiantUSBProgrammer(
            config_path=args.config,
            verbose=args.verbose
        )
        
        if args.setup_cable:
            return 0 if programmer.setup_cable() else 1
        
        if not args.bitstream:
            parser.error("--bitstream is required (or use --setup-cable)")
        
        # Determine operation
        operation = "Fast Configuration" if args.fast else args.operation
        
        # Program device
        success = programmer.program(
            args.bitstream,
            operation=operation,
            max_retries=args.max_retries
        )

        res_dir = programmer.results_dir

        # Reuse old temp log to store results directory path
        oldlog_path = os.path.join(res_dir, "programmer-old.log")
        with open(oldlog_path, 'w') as f:
            f.write(str(res_dir))
        
        file = Path(oldlog_path)
        parent = file.parent.parent      # one directory up
        new = parent / "temp.txt"  # new name

        if new.exists():
            file.replace(new)  # remove if already exists
        else:
            file.rename(new)


        # oldlog_path = os.path.join(results_dir, "programmer-old.log")
        # if os.path.exists(oldlog_path): 
        #     os.remove(oldlog_path)
        #     print("Temp log removed successfully.")
        # else:
        #     print("Temp log does not exist.")


        return res_dir if success else 1
    
    except KeyboardInterrupt:
        print("\n\nInterrupted by user")
        return 130
    except Exception as e:
        print(f"\n[✗ ERROR] {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1

if __name__ == "__main__":
    dir = main()
    #print(f"Results directory: {dir}")
    sys.exit()
